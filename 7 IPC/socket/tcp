1 滑动窗口

	滑动：“允许发送的范围”随发送过程变化
	
	- TCP两端分别维护一个独立的发送缓冲区和接收缓冲区
	- 发送窗口是发送缓存中的一部分，是可以被TCP协议发送的部分。所有的数据都放进了发送者的发送缓冲区
	- 发送数据类型
		1 已发送并收到确认 （不在发送窗口和发送缓冲区与之内
		2 已发送未收到确认 （位于发送窗口之内
		3 允许发送还没发
		4 发送缓存内但窗口外
	
	1 TCP链接的初始
		服务器告诉客户端接收窗口的大小
		客户端根据服务器的接收窗口大小构造出自己的发送窗口
	
	2 传输效率
		先单个发送字节单个确认，将后面的数据先缓存到TCP发送缓存
		发送方收到第一个字节的确认后，得到了网络状况和接收窗口大小，组合剩余报文发送出去
		到达数据达到发送窗口大小的一半或达到报文段的最大长度时就立即发送一个报文段
		
		
	3 

		
2 拥塞控制

	慢开始，快重传，快恢复
	
	过程：
		1 由“拥塞窗口”和接收端口共同决定发送者的发送窗口
		2 一开始先发送1字节的试探报文
		3 接收到第一个字节数据的确认后就发送2个字节，一次递增发送2的指数级个字节，直至一次发送的报文达到门限窗口（预先设定好值）
			若当前窗口超过门限则使用拥塞避免算法，（每经过一个RTT就将发送窗口+1，缓慢增长）
			若小于则使用慢开始算法（每次增加2的指数级个字节
		4  当出现网络拥塞或者丢包时，将慢开始门限设为 当前 窗口的一半（？），
			慢开始：将窗口有数量重新置1执行慢开始算法
			快重传：窗口置为减半后的数值，执行拥塞避免算法
			

3 差错控制
	
	3.1 发送的包丢失
		设置一个等待时间，例如RTT
		在这个等待时间之后仍然没有收到ACK，则认为数据丢失，然后重新发送数据
		
	3.2 接收端收到数据返回ACK，该ACK包丢失
		在等待时间后，发送端重发数据
		为了区分是发送的数据丢失还是响应的ACK包丢失，需要给发送的数据包进行编号
	
	3.3 发送端接收到延迟的ACK包
		丢弃
		为了区分收到的ACK包是对哪一个请求的响应，需要给每个ACK包进行编号
			

4 TCP Conclusion

	1 三次握手
		================1================
		- SYN		客户端–发送带有 SYN 标志的数据包
			在双方进行对话之前，先要进行编号的约定
			{
				发送端 告诉 接收端 ：接收端数据包编号的起始位置
					-> 例如 SYN=n-1 （一般情况下会对编号做一些简单运算再交付）
			}
		
		================2================
		- SYN/ACK	服务端–发送带有 SYN/ACK 标志的数据包
			{
				接收端 收到SYN, 得知发送端ACK编号的起始位置
					-> 例如 send.ACK=n
				接收端 同时回复 发送端 SYN, 告知接收端编号的起始位置，
					-> 例如 SYN=m-1
			}
			
		================3================
		- ACK		发送端有带有 ACK 标志的数据包
			{
				发送端收到 ACK回复 得知接收端编号的起始位值
					-> 例如 recv.ACK=m
			}
		
		（疑问？两端都收到对方的SYN就可以了，为什么还要把ACK发送回去呢）
			（可能是各端接收到了SYN，确定对方的位置的编号，需要根据当前编号重新计算一个数值表示你在自己这里的对应的其实编号，将该编号再告知对方）
			（然后双方要发送数据，就根据自己的编号，和一开始的SYN没有关系了，从计算过的SYN进行累加ACK值）
	
	 接下来传输的编号 就是当前编号加数据包的大小
	 
	 
	 注1 ：
	 	三次握手：1,2 合并起来称作半连接状态
	 	半连接池：已经和服务器建立了半连接状态的节点都放到半连接池中，当对方发起第三次握手时，则在池中找到它的信息（IP地址，端口，协议……），然后建立连接进行交互
	 	半连接洪水：占满半连接池（客户端只向服务器发送第一次握手，收到服务器的二次握手后，客户端不发送第三次握手）
	 		解决方案：放弃使用半连接池，
	 			{
	 				对方IP
	 				对方port
	 				我方IP
	 				我方port
	 				两端间的PROTOCOL
	 			} | salt
	 			对该数据进行hash处理
	 			
	 				--> 得到的内容称为 cookie
	 			
	 			在第二次握手的时候将cookie跟着packet带走，当发起第三次握手的时候需要带着刚才给的cookie过来。
	 			其中：salt是由内核产生，每秒变换一次
	 			（校验：当 当前的salt与信息计算结果与 cookie不符则用上一秒的salt计算（如果cookie过期，则肯定无法匹配））
	 	
	 	
	 注2 ：
	 	
	 	半连接状态 与 全连接状态
	 	- TCP有两个队列：
	 		1 半连接队列
	 			半连接：服务器处于Listen状态时，收到客户端SYN报文时放入半连接队列中（二次握手前
	 		2 全连接队列
	 			全连接：三次握手
		- 半连接队列
			当SYN 队列满，通过tcp_syncookies来防止syn flood攻击。方法如上所述。
			只有在SYN queue已满的情况下才会触发SYN cookies机制
	
	2 SYN
	
	
	3 其他
		- 差错控制
			- ACK丢失
				重传，接收端丢弃向A重发ACK消息
			- ACK迟到
				重传，发送端丢弃重复的ACK，接收端丢弃重复的消息
		- 自动重传请求 ARQ
			累计确认（回退N），可能造成重复发送数据，不关心ACK包的丢失
		- 滑动窗口
			实现流控
		- 拥塞控制

		
