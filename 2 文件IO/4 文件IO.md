# 系统IO （系统调用IO）

```
open , close , openat
read , write
creat

lseek

pread , pwrite

dup , dup2

sync , fsync , fdatasync

fcntl

ioctl
```



1 文件描述符 fd：在文件IO中贯穿始终的类型
2 文件IO操作 ： open, close, read, write, lseek
	区别文件IO 和 标准IO		
3 IO 的效率问题
4 文件共享
5 原子操作
6 程序中的重定向 dup， dup2
7 同步：sync, fsync, fdatasync
8 IO控制 fcntl, ioctrl
9 /dev/fd/ -> 目录

FILE结构体：文件位置指针，fd，打开计数器，……



## 1 文件描述符
```
文件：
	一个inode号，代表存在磁盘上的一个文件
	打开一个文件，得到一个结构体（文件表）
文件描述符：
	一个整型数，是文件描述符表中的下标，
	优先使用当前可用的范围内最小的
```

## 2 文件IO相关操作
```
open
(重载，变参，多态)
close

read
write

lseek (fd, offset, 相对偏移位置
```

## 3 IO效率
```
标准IO：放在缓冲区，吞吐量大
系统IO：响应速度快（?）
标准IO与文件IO不能混合使用

fileno:转换 
fdopen:封装为标准IO
```

## 4 文件共享
b --> 面试题：删除一个文件的第十行
	同一个文件在同一个进程中打开两次，一个负责读，一个负责读写。 --> 可以扩展到多进程+IPC 或者是 多线程操作

truncate : 截断一个未打开的文件
ftruncate: 截断一个已打开的文件



## 5 原子操作

不可分割的操作，用于解决竞争和冲突



## 6 重定向
每一个进程都有自己的标准输入文件、标准输出文件和标准出错文件（应该是系统自动分配的）
系统默认自动为进程的
	标准输入文件在文件描述符0上打开
	标准输出文件在文件描述符1上打开
	标准出错在文件描述符2上打开

通常情况下，是将输入设备（键盘）打开并复制到进程的标准输入（0）、将输出设备（显示器）打开并复制到标准输出（1）和标准出错（2）。
```
dup 复制一个文件描述符到可用最小文件描述符上（可能产生错误
	1 可能dup一个已释放的fd
	2 多线程的时候，关闭一个还未复制时，另一个线程占用了需要的fd
	
dup2 指定oldfd和newfd（是一个原子操作，dup后立马close，但是当两个fd相等时，fd已关闭不用再去关闭fd
```

>dup函数返回当前系统可用的最小整数值。
>dup2函数返回第一个不小于newfd的整数值。也就是分为两种情况：
>① 如果newfd已经打开，则先将其关闭，再复制文件描述符 --》这两步是一个原子操作过程。
>② 如果newfd等于oldfd，则dup2返回newfd, 而不关闭它。

## 7 同步

sync ： 同步内核层面的buffer和cache （应用场景：在解除设备挂在时，内核需要将还在buffer和cache中的数据同步刷新一下，然后再进行解除设挂载
fsync： 同步一个文件的buffer或者cache
fdatasync： 只刷数据不刷新亚数据。数据：文件的有效内容。亚数据：文件的最后修改时间等。
	
fcntl：
ioctl：基于1.3.27内核，设备相关内容
	
/dev/fd ：虚目录，显示当前进程的文件描述符信息